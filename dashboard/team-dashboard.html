<!doctype html>
<html lang="en">
<head>
  <meta charset="UTF-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1.0" />
  <title>Cypher Matrix Team Dashboard</title>
  <style>
    :root {
      --bg: #050b07;
      --card: #0c1710;
      --muted: #9cc7a9;
      --text: #e8fff0;
      --ok: #49ff8f;
      --border: #1f3a2c;
      --accent: #39ff88;
      --panel: #0a140e;
    }
    * { box-sizing: border-box; }
    body {
      margin: 0;
      font-family: Inter, system-ui, -apple-system, Segoe UI, Roboto, Arial, sans-serif;
      background: radial-gradient(circle at top, #0a1b11 0%, #050b07 45%, #030604 100%);
      color: var(--text);
    }
    .wrap { max-width: 1200px; margin: 0 auto; padding: 24px; }
    h1 { margin: 0 0 8px; font-size: 28px; }
    h2 { margin: 22px 0 10px; font-size: 20px; }
    .sub { color: var(--muted); margin-bottom: 20px; }
    .top { display: grid; grid-template-columns: repeat(auto-fit, minmax(220px, 1fr)); gap: 12px; margin-bottom: 18px; }
    .kpi, .card, .kanban-col { background: rgba(10,20,14,0.96); border: 1px solid var(--border); border-radius: 14px; padding: 14px; box-shadow: 0 0 0 1px rgba(57,255,136,.05) inset; }
    .kpi .label, .row .label { color: var(--muted); font-size: 12px; text-transform: uppercase; letter-spacing: .08em; }
    .kpi .value { font-size: 20px; margin-top: 6px; font-weight: 700; }
    .ok { color: var(--ok); }
    .agents { display: grid; grid-template-columns: repeat(auto-fit, minmax(280px, 1fr)); gap: 12px; }
    .agent-name { font-size: 18px; margin: 0 0 4px; }
    .badge { display: inline-block; border: 1px solid #28523a; color: #86efac; padding: 2px 8px; border-radius: 999px; font-size: 12px; margin-bottom: 10px; }
    .row { margin: 8px 0; }
    .row .value { margin-top: 3px; line-height: 1.35; }
    ul { margin: 8px 0 0 18px; padding: 0; }
    li { margin: 4px 0; }
    .footer { margin-top: 16px; color: var(--muted); font-size: 12px; }
    .btn { background: #135f33; color: #ecfff2; border: 1px solid #2ca45c; border-radius: 10px; padding: 8px 12px; cursor: pointer; margin-left: 10px; }
    .task-form { margin: 8px 0 14px; display: grid; grid-template-columns: 1.4fr 1fr 0.8fr 1.4fr auto; gap: 8px; }
    .task-form input, .task-form select { background: #0b1811; color: var(--text); border: 1px solid #295238; border-radius: 8px; padding: 8px; font-size: 13px; }
    .task-form .btn { margin-left: 0; }

    .kanban { display: grid; grid-template-columns: repeat(4, minmax(220px, 1fr)); gap: 12px; align-items: start; }
    .kanban-col h3 { margin: 0 0 10px; font-size: 14px; text-transform: uppercase; letter-spacing: .08em; color: var(--muted); }
    .dropzone { min-height: 90px; border: 1px dashed #2b5b3e; border-radius: 10px; padding: 8px; transition: .12s ease; }
    .dropzone.drag-over { border-color: #39ff88; background: rgba(57,255,136,.12); }
    .task { border: 1px solid #2b5b3e; border-radius: 10px; padding: 10px; margin-bottom: 8px; background: #0d1b12; cursor: grab; }
    .task:active { cursor: grabbing; }
    .task-title { font-size: 14px; margin: 0 0 6px; font-weight: 600; }
    .task-meta { font-size: 11px; color: var(--muted); display: flex; gap: 8px; flex-wrap: wrap; }
    .task details { margin-top: 8px; border-top: 1px solid #27345f; padding-top: 8px; }
    .task summary { cursor: pointer; color: #8dffb8; font-size: 12px; }
    .task-details { margin-top: 6px; font-size: 12px; color: #d9fbe6; }
    .task-details .section-title { color: var(--muted); font-size: 11px; text-transform: uppercase; letter-spacing: .06em; margin-top: 6px; }
    .task-details ul { margin: 4px 0 0 16px; }
    .pill { display: inline-block; border: 1px solid #475569; border-radius: 999px; padding: 1px 7px; font-size: 11px; }
    .p-high { border-color: #7f1d1d; color: #fca5a5; }
    .p-medium { border-color: #78350f; color: #fcd34d; }
    .p-low { border-color: #1e3a8a; color: #93c5fd; }
    .p-init { border-color: #065f46; color: #6ee7b7; }
    .trace-grid { display: grid; grid-template-columns: 1.25fr 1fr; gap: 12px; margin-top: 12px; }
    .relay-card { min-height: 220px; }
    .trace-feed, .activity-feed { max-height: 320px; overflow: auto; border: 1px solid #284f36; border-radius: 10px; background: #0b1811; padding: 8px; }
    .trace-item, .activity-item { border: 1px solid #2a5238; border-radius: 9px; padding: 8px; margin-bottom: 8px; background: #0d1d14; }
    .trace-item summary { cursor: pointer; list-style: none; }
    .trace-item summary::-webkit-details-marker { display: none; }
    .trace-time, .activity-time { color: var(--muted); font-size: 11px; margin-bottom: 4px; }
    .trace-msg { font-size: 13px; line-height: 1.35; }
    .activity-title { font-size: 13px; margin-bottom: 4px; }
    .activity-meta { color: var(--muted); font-size: 12px; }
    .dot { display: inline-block; width: 8px; height: 8px; border-radius: 50%; background: #39ff88; box-shadow: 0 0 0 0 rgba(57,255,136,.75); margin-right: 7px; animation: pulse 1.7s infinite; }
    @keyframes pulse {
      0% { box-shadow: 0 0 0 0 rgba(57,255,136,.75); }
      70% { box-shadow: 0 0 0 10px rgba(57,255,136,0); }
      100% { box-shadow: 0 0 0 0 rgba(57,255,136,0); }
    }
    .toast { position: fixed; right: 16px; bottom: 16px; background: #102216; border: 1px solid #2f7a4d; color: #ecfff2; padding: 10px 12px; border-radius: 10px; font-size: 13px; opacity: 0; transform: translateY(8px); transition: .2s; z-index: 20; }
    .toast.show { opacity: 1; transform: translateY(0); }
    .activity { margin-top: 14px; background: rgba(12,18,37,.95); border: 1px solid var(--border); border-radius: 12px; padding: 10px; max-height: 180px; overflow: auto; }
    .activity h3 { margin: 0 0 8px; font-size: 13px; color: var(--muted); text-transform: uppercase; letter-spacing: .08em; }
    .event { font-size: 12px; border-bottom: 1px solid #233052; padding: 6px 0; color: #cbd5e1; }
    .event:last-child { border-bottom: 0; }

    @media (max-width: 980px) { .kanban { grid-template-columns: 1fr 1fr; } .trace-grid { grid-template-columns: 1fr; } }
    @media (max-width: 640px) { .kanban { grid-template-columns: 1fr; } }
  </style>
</head>
<body>
  <div class="wrap">
    <h1>Cypher Matrix Dashboard</h1>
    <div class="sub">
      Team visibility + draggable Kanban (move cards to start work).
      <button class="btn" onclick="refreshAll()">Refresh</button>
      <button class="btn" onclick="resetBoard()">Reset Board</button>
    </div>

    <div class="top" id="top"></div>

    <h2>Agent Status</h2>
    <div class="agents" id="agents"></div>

    <h2>Kanban Board</h2>
    <div class="sub" id="kanbanMeta">Loading task board...</div>
    <div class="task-form">
      <input id="newTaskTitle" placeholder="Task title (concise)" />
      <select id="newTaskAgent">
        <option value="main">main</option>
        <option value="architect">architect</option>
        <option value="morpheus">morpheus</option>
        <option value="trinity">trinity</option>
        <option value="oracle">oracle</option>
      </select>
      <select id="newTaskPriority">
        <option value="high">high</option>
        <option value="medium" selected>medium</option>
        <option value="low">low</option>
      </select>
      <input id="newTaskActions" placeholder="Action items (comma separated)" />
      <button class="btn" onclick="createTaskFromForm()">Add Task</button>
    </div>
    <div class="kanban" id="kanban"></div>

    <h2>Execution Trace</h2>
    <div class="trace-grid">
      <div class="card relay-card">
        <div class="row"><div class="label">Real-time Progress Relay</div></div>
        <div class="trace-feed" id="traceFeed"></div>
      </div>
      <div class="card relay-card">
        <div class="row"><div class="label">Live In-Progress Activity</div></div>
        <div class="activity-feed" id="activityFeed"></div>
      </div>
    </div>

    <div class="footer" id="footer"></div>
  </div>
  <div id="toast" class="toast"></div>

  <script>
    const KANBAN_COLUMNS = [
      { id: 'todo', label: 'To Do' },
      { id: 'in-progress', label: 'In Progress' },
      { id: 'blocked', label: 'Blocked' },
      { id: 'done', label: 'Done' }
    ];

    let baseKanban = null;
    let boardState = null;
    let progressRelay = [];
    let progressTicker = null;
    let slackNotifyConfig = null;

    const RELAY_LIMIT = 120;
    const NOTIFY_DEDUPE_WINDOW_MS = 90 * 1000;
    const TRACE_STEPS = [
      'Bootstrapping execution context',
      'Pulling latest dependencies',
      'Running active checks',
      'Applying incremental updates',
      'Verifying outputs'
    ];

    function esc(str = '') {
      return String(str).replaceAll('&', '&amp;').replaceAll('<', '&lt;').replaceAll('>', '&gt;').replaceAll('"', '&quot;').replaceAll("'", '&#39;');
    }

    function showToast(msg) {
      const t = document.getElementById('toast');
      t.textContent = msg;
      t.classList.add('show');
      setTimeout(() => t.classList.remove('show'), 1700);
    }

    function nextTaskId(agent) {
      const prefixMap = { main: 'C', architect: 'A', morpheus: 'M', trinity: 'T', oracle: 'O' };
      const prefix = prefixMap[agent] || 'X';
      const nums = (boardState?.tasks || [])
        .map(t => String(t.id || ''))
        .filter(id => id.startsWith(prefix + '-'))
        .map(id => Number(id.split('-')[1]))
        .filter(n => Number.isFinite(n));
      const next = (nums.length ? Math.max(...nums) : 0) + 1;
      return `${prefix}-${String(next).padStart(3, '0')}`;
    }

    async function createTaskFromForm() {
      if (!boardState) return;
      const titleEl = document.getElementById('newTaskTitle');
      const agentEl = document.getElementById('newTaskAgent');
      const priorityEl = document.getElementById('newTaskPriority');
      const actionsEl = document.getElementById('newTaskActions');

      const title = (titleEl?.value || '').trim();
      if (!title) {
        showToast('Add a task title first');
        return;
      }

      const agent = agentEl?.value || 'main';
      const priority = priorityEl?.value || 'medium';
      const actionItems = (actionsEl?.value || '')
        .split(',')
        .map(x => x.trim())
        .filter(Boolean);

      const task = {
        id: nextTaskId(agent),
        shortTitle: title,
        title,
        agent,
        status: 'todo',
        priority,
        actionItems,
        comments: []
      };

      boardState.tasks.unshift(task);
      boardState.updatedAt = new Date().toISOString();
      saveBoard();
      drawKanban();
      relay('New task created in To Do', { taskId: task.id, agent: task.agent });
      await sendTaskEventToBackend('task_created', task);
      showToast(`Task added: ${task.id}`);

      titleEl.value = '';
      actionsEl.value = '';
    }

    function formatTime(ts) {
      return new Date(ts).toLocaleTimeString();
    }

    function formatElapsed(startedAt) {
      if (!startedAt) return 'not started';
      const secs = Math.max(0, Math.floor((Date.now() - new Date(startedAt).getTime()) / 1000));
      const m = Math.floor(secs / 60).toString().padStart(2, '0');
      const s = (secs % 60).toString().padStart(2, '0');
      return `${m}:${s}`;
    }

    function relay(event, options = {}) {
      if (!boardState) return;
      const item = {
        at: new Date().toISOString(),
        taskId: options.taskId || null,
        agent: options.agent || null,
        message: event
      };
      progressRelay.unshift(item);
      progressRelay = progressRelay.slice(0, RELAY_LIMIT);
      boardState.relay = progressRelay;
      boardState.updatedAt = item.at;
      saveBoard();
      renderTrace();
    }

    function classifyTrace(item) {
      const msg = String(item.message || '').toLowerCase();
      if (/fail|error|exception|timeout|stalled|blocked/.test(msg)) return 'issue';
      if (/complete|done|success/.test(msg)) return 'success';
      return 'info';
    }

    function traceHints(item) {
      const msg = String(item.message || '').toLowerCase();
      if (/timeout/.test(msg)) return ['Check service reachability', 'Retry the operation', 'Inspect gateway/channel logs'];
      if (/cors|network/.test(msg)) return ['Verify webhook endpoint allows request origin', 'Confirm URL/token are valid', 'Retry after connectivity check'];
      if (/fail|error|exception/.test(msg)) return ['Open logs for this agent/task', 'Capture exact error text', 'Escalate if repeated 2+ times'];
      if (/blocked|stalled/.test(msg)) return ['Identify dependency/owner', 'Set unblock action + ETA', 'Escalate to Architect if unresolved'];
      return ['No immediate issue detected', 'Continue monitoring relay updates'];
    }

    function renderTrace() {
      const container = document.getElementById('traceFeed');
      if (!container) return;
      if (!progressRelay.length) {
        container.innerHTML = '<div class="trace-item"><div class="trace-msg">No execution events yet. Move a task to In Progress to start the relay.</div></div>';
        return;
      }

      container.innerHTML = progressRelay.map((item, idx) => {
        const cls = classifyTrace(item);
        const badge = cls === 'issue' ? '⚠ issue' : cls === 'success' ? '✓ success' : '• info';
        const hints = traceHints(item);
        return `
        <details class="trace-item" ${idx === 0 ? 'open' : ''}>
          <summary>
            <div class="trace-time">${esc(formatTime(item.at))}${item.taskId ? ` • ${esc(item.taskId)}` : ''}${item.agent ? ` • ${esc(item.agent)}` : ''}</div>
            <div class="trace-msg">${esc(item.message)} <span class="pill">${badge}</span></div>
          </summary>
          <div class="task-details">
            <div class="section-title">Diagnostics</div>
            <ul>${hints.map(h => `<li>${esc(h)}</li>`).join('')}</ul>
          </div>
        </details>
      `;
      }).join('');
    }

    function renderActivity() {
      const container = document.getElementById('activityFeed');
      if (!container) return;
      const active = (boardState?.tasks || []).filter(t => t.status === 'in-progress');
      if (!active.length) {
        container.innerHTML = '<div class="activity-item"><div class="activity-title">No active tasks</div><div class="activity-meta">Drop a card into In Progress to see live execution signals.</div></div>';
        return;
      }

      container.innerHTML = active.map(t => `
        <div class="activity-item">
          <div class="activity-title"><span class="dot"></span>${esc(t.id)} — ${esc(t.title)}</div>
          <div class="activity-meta">Agent: ${esc(t.agent)} • Running: ${esc(formatElapsed(t.initiatedAt))} • Last trace: ${esc(t.lastTrace || 'initiated')}</div>
        </div>
      `).join('');
    }

    function saveBoard() {
      localStorage.setItem('cypher-kanban-state', JSON.stringify(boardState));
    }

    function loadSavedBoard() {
      const raw = localStorage.getItem('cypher-kanban-state');
      if (!raw) return null;
      try { return JSON.parse(raw); } catch { return null; }
    }

    function resolveActor() {
      const actorFromQuery = new URLSearchParams(window.location.search).get('actor');
      if (actorFromQuery) {
        localStorage.setItem('cypher-actor', actorFromQuery);
        return actorFromQuery;
      }
      return localStorage.getItem('cypher-actor') || null;
    }

    function readNotifyDedupe() {
      try { return JSON.parse(localStorage.getItem('cypher-notify-dedupe') || '{}'); } catch { return {}; }
    }

    function writeNotifyDedupe(map) {
      localStorage.setItem('cypher-notify-dedupe', JSON.stringify(map));
    }

    function shouldNotifyEvent(sig) {
      const now = Date.now();
      const dedupe = readNotifyDedupe();
      for (const [k, ts] of Object.entries(dedupe)) {
        if (!Number.isFinite(ts) || now - ts > NOTIFY_DEDUPE_WINDOW_MS) delete dedupe[k];
      }
      const isBlocked = dedupe[sig] && (now - dedupe[sig] < NOTIFY_DEDUPE_WINDOW_MS);
      if (isBlocked) return false;
      dedupe[sig] = now;
      writeNotifyDedupe(dedupe);
      return true;
    }

    async function loadSlackNotifyConfig() {
      try {
        const res = await fetch('./slack-notify-config.json?ts=' + Date.now());
        if (!res.ok) return;
        slackNotifyConfig = await res.json();
      } catch {
        slackNotifyConfig = null;
      }
    }

    async function sendTaskEventToBackend(eventType, task, details = {}) {
      if (!slackNotifyConfig?.enabled) return;
      const relayUrl = slackNotifyConfig.relayUrl || 'http://127.0.0.1:8787/notify';
      const actor = resolveActor() || slackNotifyConfig.defaultActor || 'unknown';
      const timestamp = new Date().toISOString();
      const dedupeSig = [eventType, task.id, details.from || '', details.to || '', actor].join('|').toLowerCase();
      if (!shouldNotifyEvent(dedupeSig)) return;

      const lines = [
        `Kanban event: ${eventType}`,
        `Task: ${task.id} — ${task.title}`,
        `Agent: ${task.agent}`
      ];
      if (details.from || details.to) lines.push(`Transition: ${details.from || 'n/a'} -> ${details.to || 'n/a'}`);
      lines.push(`Timestamp: ${timestamp}`);
      lines.push(`Actor: ${actor}`);
      const text = lines.join('\n');

      try {
        const res = await fetch(relayUrl, {
          method: 'POST',
          headers: { 'Content-Type': 'application/json' },
          body: JSON.stringify({
            text,
            eventType,
            threadTs: slackNotifyConfig.threadTs || '',
            task: {
              id: task.id,
              title: task.title,
              agent: task.agent
            },
            transition: details.from || details.to ? { from: details.from || '', to: details.to || '' } : undefined,
            actor,
            timestamp
          })
        });

        if (!res.ok) {
          relay(`Slack relay failed: HTTP ${res.status}`, { taskId: task.id, agent: task.agent });
        } else {
          relay(`Slack relay accepted event: ${eventType}`, { taskId: task.id, agent: task.agent });
        }
      } catch (err) {
        relay(`Slack relay failed: ${err?.message || 'network'}`, { taskId: task.id, agent: task.agent });
      }
    }

    async function loadTeam() {
      const res = await fetch('./team-status.json?ts=' + Date.now());
      const data = await res.json();

      document.getElementById('top').innerHTML = `
        <div class="kpi"><div class="label">Overall Health</div><div class="value ok">${esc(data.summary.overallHealth)}</div></div>
        <div class="kpi"><div class="label">Primary Channel</div><div class="value">${esc(data.summary.primaryChannel)}</div></div>
        <div class="kpi"><div class="label">Gateway</div><div class="value">${esc(data.summary.gateway)}</div></div>
        <div class="kpi"><div class="label">Active Agents</div><div class="value">${esc(data.summary.activeAgents)}</div></div>
      `;

      document.getElementById('agents').innerHTML = data.agents.map(a => `
        <div class="card">
          <h3 class="agent-name">${esc(a.name)}</h3>
          <div class="badge">${esc(a.status)}</div>
          <div class="row"><div class="label">Objective</div><div class="value">${esc(a.objective)}</div></div>
          <div class="row"><div class="label">Current Focus</div><div class="value">${esc(a.focus)}</div></div>
          <div class="row"><div class="label">Next Actions</div><ul>${(a.nextActions||[]).map(x=>`<li>${esc(x)}</li>`).join('')}</ul></div>
        </div>
      `).join('');

      document.getElementById('footer').textContent = `Generated: ${data.generatedAt}  •  Mission: ${data.teamMission}`;
    }

    function renderTask(task) {
      const p = (task.priority || 'low').toLowerCase();
      const priorityClass = p === 'high' ? 'p-high' : p === 'medium' ? 'p-medium' : 'p-low';
      const init = task.initiatedAt ? `<span class="pill p-init">started ${new Date(task.initiatedAt).toLocaleTimeString()}</span>` : '';
      const conciseTitle = task.shortTitle || task.title;
      const actionItems = (task.actionItems || []).map(x => `<li>${esc(x)}</li>`).join('') || '<li>No action items yet</li>';
      const comments = (task.comments || []).map(c => `<li>${esc(c)}</li>`).join('') || '<li>No completion comments yet</li>';
      return `
        <div class="task" draggable="true" data-id="${esc(task.id)}">
          <div class="task-title">${esc(conciseTitle)}</div>
          <div class="task-meta">
            <span class="pill">${esc(task.id)}</span>
            <span class="pill">${esc(task.agent)}</span>
            <span class="pill ${priorityClass}">${esc(p)}</span>
            ${init}
          </div>
          <details>
            <summary>View action items & comments</summary>
            <div class="task-details">
              <div class="section-title">Action Items</div>
              <ul>${actionItems}</ul>
              <div class="section-title">Comments</div>
              <ul>${comments}</ul>
            </div>
          </details>
        </div>
      `;
    }

    async function moveTask(taskId, newStatus) {
      const t = boardState.tasks.find(x => x.id === taskId);
      if (!t) return;
      const from = t.status;
      if (from === newStatus) return;
      t.status = newStatus;
      if (newStatus === 'in-progress') {
        if (!t.initiatedAt) t.initiatedAt = new Date().toISOString();
        t.initiated = true;
        t.lastTrace = 'Execution started';
        showToast(`Initiated: ${t.id} (${t.agent})`);
        relay(`Execution initiated (${from} → in-progress)`, { taskId: t.id, agent: t.agent });
      } else {
        t.lastTrace = `Moved to ${newStatus}`;
        showToast(`Moved ${t.id}: ${from} → ${newStatus}`);
        relay(`Status changed (${from} → ${newStatus})`, { taskId: t.id, agent: t.agent });
      }

      if (newStatus === 'done') {
        t.completedAt = new Date().toISOString();
        if (!Array.isArray(t.comments)) t.comments = [];
        t.comments.unshift(`ClawBot: completed and moved to Done at ${new Date(t.completedAt).toLocaleString()}.`);
      }
      boardState.updatedAt = new Date().toISOString();
      saveBoard();
      drawKanban();
      await sendTaskEventToBackend('task_transition', t, { from, to: newStatus });
    }

    function wireDnD() {
      document.querySelectorAll('.task').forEach(el => {
        el.addEventListener('dragstart', (e) => {
          e.dataTransfer.setData('text/plain', el.dataset.id);
        });
      });

      document.querySelectorAll('.dropzone').forEach(zone => {
        zone.addEventListener('dragover', (e) => {
          e.preventDefault();
          zone.classList.add('drag-over');
        });
        zone.addEventListener('dragleave', () => zone.classList.remove('drag-over'));
        zone.addEventListener('drop', async (e) => {
          e.preventDefault();
          zone.classList.remove('drag-over');
          const taskId = e.dataTransfer.getData('text/plain');
          await moveTask(taskId, zone.dataset.status);
        });
      });
    }

    function startProgressTicker() {
      if (progressTicker) clearInterval(progressTicker);
      progressTicker = setInterval(async () => {
        if (!boardState?.tasks?.length) return;
        const active = boardState.tasks.filter(t => t.status === 'in-progress');
        if (!active.length) {
          renderActivity();
          return;
        }

        const task = active[Math.floor(Math.random() * active.length)];
        const step = TRACE_STEPS[Math.floor(Math.random() * TRACE_STEPS.length)];
        task.lastTrace = step;
        relay(step, { taskId: task.id, agent: task.agent });

        const elapsedMs = task.initiatedAt ? (Date.now() - new Date(task.initiatedAt).getTime()) : 0;
        const readyToAutoComplete = elapsedMs > 18000 && step === 'Verifying outputs';
        if (readyToAutoComplete) {
          relay('Execution complete — moving card to Done', { taskId: task.id, agent: task.agent });
          await moveTask(task.id, 'done');
          return;
        }

        renderActivity();
      }, 6000);
    }

    function drawKanban() {
      const grouped = { 'todo': [], 'in-progress': [], 'blocked': [], 'done': [] };
      for (const t of (boardState.tasks || [])) if (grouped[t.status]) grouped[t.status].push(t);

      document.getElementById('kanban').innerHTML = KANBAN_COLUMNS.map(col => `
        <div class="kanban-col">
          <h3>${col.label} (${grouped[col.id].length})</h3>
          <div class="dropzone" data-status="${col.id}">
            ${grouped[col.id].map(renderTask).join('') || '<div class="task"><div class="task-title">No tasks</div></div>'}
          </div>
        </div>
      `).join('');

      document.getElementById('kanbanMeta').textContent = `Drag cards between columns. Dropping into In Progress auto-initiates the task, emits relay traces, and pushes task events to the local backend relay. Last update: ${boardState.updatedAt}`;
      wireDnD();
      renderTrace();
      renderActivity();
    }

    function mergeBoardWithBase(saved, base) {
      if (!saved || !Array.isArray(saved.tasks)) return structuredClone(base);

      const baseUpdatedAtMs = new Date(base?.updatedAt || 0).getTime();
      const savedUpdatedAtMs = new Date(saved?.updatedAt || 0).getTime();
      const baseIsNewer = Number.isFinite(baseUpdatedAtMs) && baseUpdatedAtMs > savedUpdatedAtMs;

      const savedById = new Map(saved.tasks.map(t => [t.id, t]));
      const mergedTasks = (base.tasks || []).map(task => {
        const prev = savedById.get(task.id);
        if (!prev) return structuredClone(task);

        const preferBaseDone = baseIsNewer && task.status === 'done' && prev.status !== 'done';

        return {
          ...task,
          status: preferBaseDone ? task.status : (prev.status || task.status),
          initiatedAt: prev.initiatedAt || task.initiatedAt,
          initiated: prev.initiated || task.initiated,
          lastTrace: prev.lastTrace || task.lastTrace
        };
      });

      return {
        ...structuredClone(base),
        tasks: mergedTasks,
        relay: Array.isArray(saved.relay) ? saved.relay.slice(0, RELAY_LIMIT) : [],
        updatedAt: baseIsNewer ? base.updatedAt : (saved.updatedAt || base.updatedAt)
      };
    }

    async function loadKanban() {
      const res = await fetch('./kanban-tasks.json?ts=' + Date.now());
      baseKanban = await res.json();
      const saved = loadSavedBoard();
      boardState = mergeBoardWithBase(saved, baseKanban);
      progressRelay = Array.isArray(boardState.relay) ? boardState.relay : [];
      if (!progressRelay.length) {
        relay('Kanban relay online: awaiting task transitions');
      }
      saveBoard();
      drawKanban();
      startProgressTicker();
    }

    function resetBoard() {
      if (!baseKanban) return;
      boardState = structuredClone(baseKanban);
      progressRelay = [];
      relay('Board reset to file defaults');
      saveBoard();
      drawKanban();
      showToast('Board reset to file defaults');
    }

    async function refreshAll() {
      await Promise.all([loadSlackNotifyConfig(), loadTeam(), loadKanban()]);
    }

    refreshAll();
  </script>
</body>
</html>
